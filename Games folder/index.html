<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Game Hub</title>
  <style>
    body {
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
    }

    #menu {
      margin-top: 50px;
    }

    button {
      padding: 15px 30px;
      margin: 10px;
      font-size: 20px;
      cursor: pointer;
    }

    #gameCanvas {
      background: black;
      display: none;
      margin: 20px auto;
      border: 2px solid white;
    }

    #controls {
      display: none;
      margin: 20px;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      color: white;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 10;
    }

    #overlay h2 {
      font-size: 40px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>

<h1>Game Hub</h1>

<div id="menu">
  <button onclick="selectGame('pong')">Play Pong</button>
  <button onclick="selectGame('snake')">Play Snake</button>
  <button onclick="selectGame('space')">Play Space Invaders</button>
</div>

<div id="controls">
  <button onclick="startCurrentGame()">Start</button>
  <button onclick="goBack()">Back</button>
</div>

<canvas id="gameCanvas" width="600" height="400"></canvas>

<div id="overlay">
  <h2 id="gameOverText">Game Over</h2>
  <p id="finalScore"></p>
  <button onclick="restartGame()">Restart</button>
  <button onclick="exitToMenu()">Return to Menu</button>
</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const finalScoreText = document.getElementById('finalScore');
  let currentGame = null;
  let currentGameName = null;

  function selectGame(game) {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('controls').style.display = 'block';
    canvas.style.display = 'block';
    currentGameName = game;
  }

  function startCurrentGame() {
    if (currentGame && currentGame.stop) currentGame.stop();
    overlay.style.display = 'none';

    if (currentGameName === 'pong') {
      currentGame = PongGame(canvas);
      currentGame.start();
    } else if (currentGameName === 'snake') {
      currentGame = SnakeGame(canvas);
      currentGame.start();
    } else if (currentGameName === 'space') {
      currentGame = SpaceInvadersGame(canvas);
      currentGame.start();
    }
  }

  function goBack() {
    if (currentGame && currentGame.stop) currentGame.stop();
    canvas.style.display = 'none';
    document.getElementById('controls').style.display = 'none';
    document.getElementById('menu').style.display = 'block';
    overlay.style.display = 'none';
  }

  function showGameOver(score) {
    overlay.style.display = 'flex';
    finalScoreText.innerText = "Final Score: " + score;
  }

  function restartGame() {
    overlay.style.display = 'none';
    startCurrentGame();
  }

  function exitToMenu() {
    overlay.style.display = 'none';
    goBack();
  }

  // -------------------- PONG --------------------
  function PongGame(canvas) {
    const ctx = canvas.getContext("2d");
    let paddleHeight = 80, paddleWidth = 10;
    let playerY = canvas.height / 2 - paddleHeight / 2;
    let aiY = playerY;
    let ballSize = 15;
    let ballX = canvas.width / 2;
    let ballY = canvas.height / 2;
    let ballSpeedX = 5;
    let ballSpeedY = 3;
    let playerScore = 0, aiScore = 0;
    let running = false;
    let animationFrameId;

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'white';

      // Paddles
      ctx.fillRect(10, playerY, paddleWidth, paddleHeight);
      ctx.fillRect(canvas.width - 20, aiY, paddleWidth, paddleHeight);

      // Ball
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballSize / 2, 0, Math.PI * 2);
      ctx.fill();

      // Scoreboard
      ctx.font = "20px Arial";
      ctx.fillText(playerScore, canvas.width / 4, 30);
      ctx.fillText(aiScore, (canvas.width * 3) / 4, 30);
    }

    function update() {
      ballX += ballSpeedX;
      ballY += ballSpeedY;

      if (ballY <= ballSize / 2 || ballY >= canvas.height - ballSize / 2) ballSpeedY *= -1;

      if (ballX - ballSize / 2 <= 20 && ballY > playerY && ballY < playerY + paddleHeight)
        ballSpeedX *= -1;

      if (ballX + ballSize / 2 >= canvas.width - 20 && ballY > aiY && ballY < aiY + paddleHeight)
        ballSpeedX *= -1;

      if (ballX < 0) {
        aiScore++;
        if (aiScore >= 5) { endGame(); return; }
        resetBall();
      } else if (ballX > canvas.width) {
        playerScore++;
        if (playerScore >= 5) { endGame(); return; }
        resetBall();
      }

      if (aiY + paddleHeight / 2 < ballY) aiY += 4;
      else aiY -= 4;
      aiY = Math.max(0, Math.min(canvas.height - paddleHeight, aiY));
    }

    function resetBall() {
      ballX = canvas.width / 2;
      ballY = canvas.height / 2;
      ballSpeedX *= -1;
    }

    function gameLoop() {
      if (!running) return;
      update();
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    window.onkeydown = function(e) {
      if (e.key === 'ArrowUp') playerY = Math.max(playerY - 15, 0);
      else if (e.key === 'ArrowDown') playerY = Math.min(playerY + 15, canvas.height - paddleHeight);
    };

    function endGame() {
      stop();
      showGameOver(playerScore);
    }

    function start() {
      running = true;
      gameLoop();
    }

    function stop() {
      running = false;
      cancelAnimationFrame(animationFrameId);
    }

    return { start, stop };
  }

  // -------------------- SNAKE --------------------
  function SnakeGame(canvas) {
    const ctx = canvas.getContext("2d");
    const tileSize = 20;
    const tileCountX = canvas.width / tileSize;
    const tileCountY = canvas.height / tileSize;

    let snake, food, velocity, animationFrameId;
    let running = false;
    let directionQueue = [];
    let score = 0;
    let frameCounter = 0;

    function init() {
      snake = [{ x: 10, y: 10 }];
      velocity = { x: 1, y: 0 };
      directionQueue = [];
      placeFood();
      score = 0;
    }

    function placeFood() {
      food = {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY),
      };
    }

    function draw() {
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "lime";
      for (let part of snake) {
        ctx.fillRect(part.x * tileSize, part.y * tileSize, tileSize, tileSize);
      }

      ctx.fillStyle = "red";
      ctx.fillRect(food.x * tileSize, food.y * tileSize, tileSize, tileSize);

      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 10, 20);
    }

    function update() {
      frameCounter++;
      if (frameCounter % 8 !== 0) return; // slower speed

      if (directionQueue.length) {
        const nextDir = directionQueue.shift();
        if (nextDir.x !== -velocity.x && nextDir.y !== -velocity.y) {
          velocity = nextDir;
        }
      }

      const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

      if (
        head.x < 0 || head.x >= tileCountX ||
        head.y < 0 || head.y >= tileCountY ||
        snake.some(part => part.x === head.x && part.y === head.y)
      ) {
        endGame();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score++;
        placeFood();
      } else {
        snake.pop();
      }
    }

    function gameLoop() {
      if (!running) return;
      update();
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function endGame() {
      stop();
      showGameOver(score);
    }

    function start() {
      init();
      running = true;
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function stop() {
      running = false;
      cancelAnimationFrame(animationFrameId);
    }

    window.addEventListener("keydown", (e) => {
      if (!running) return;
      switch (e.key) {
        case "ArrowUp": directionQueue.push({ x: 0, y: -1 }); break;
        case "ArrowDown": directionQueue.push({ x: 0, y: 1 }); break;
        case "ArrowLeft": directionQueue.push({ x: -1, y: 0 }); break;
        case "ArrowRight": directionQueue.push({ x: 1, y: 0 }); break;
      }
    });

    return { start, stop };
  }

  // -------------------- SPACE INVADERS --------------------
  function SpaceInvadersGame(canvas) {
    const ctx = canvas.getContext('2d');
    let playerX = canvas.width / 2 - 20;
    let bullets = [];
    let enemies = [];
    let enemyDirection = 1;
    let enemySpeed = 1;
    let animationFrameId;
    let running = false;
    let score = 0;

    function init() {
      bullets = [];
      enemies = [];
      for (let y = 0; y < 3; y++) {
        for (let x = 0; x < 8; x++) {
          enemies.push({ x: 60 + x * 50, y: 30 + y * 40, alive: true });
        }
      }
      score = 0;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw player
      ctx.fillStyle = 'cyan';
      ctx.fillRect(playerX, canvas.height - 20, 40, 10);

      // Draw bullets
      ctx.fillStyle = 'white';
      bullets.forEach(b => ctx.fillRect(b.x, b.y, 4, 10));

      // Draw enemies
      ctx.fillStyle = 'lime';
      enemies.forEach(e => {
        if (e.alive) ctx.fillRect(e.x, e.y, 30, 20);
      });

      // Scoreboard
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 10, 20);
    }

    function update() {
      bullets = bullets.filter(b => b.y > 0);
      bullets.forEach(b => b.y -= 5);

      bullets.forEach(b => {
        enemies.forEach(e => {
          if (e.alive && b.x >= e.x && b.x <= e.x + 30 && b.y >= e.y && b.y <= e.y + 20) {
            e.alive = false;
            b.y = -10;
            score += 10;
          }
        });
      });

      let moveDown = false;
      enemies.forEach(e => {
        if (e.alive) {
          e.x += enemySpeed * enemyDirection;
          if (e.x <= 10 || e.x >= canvas.width - 40) moveDown = true;
        }
      });

      if (moveDown) {
        enemyDirection *= -1;
        enemies.forEach(e => e.y += 20);
      }

      // Game Over if enemies reach bottom
      if (enemies.some(e => e.alive && e.y >= canvas.height - 40)) {
        endGame();
      }
    }

    function gameLoop() {
      if (!running) return;
      update();
      draw();
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function endGame() {
      stop();
      showGameOver(score);
    }

    function start() {
      init();
      running = true;
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function stop() {
      running = false;
      cancelAnimationFrame(animationFrameId);
    }

    window.addEventListener('keydown', (e) => {
      if (!running) return;
      if (e.key === 'ArrowLeft') playerX = Math.max(0, playerX - 20);
      if (e.key === 'ArrowRight') playerX = Math.min(canvas.width - 40, playerX + 20);
      if (e.key === ' ') bullets.push({ x: playerX + 18, y: canvas.height - 30 });
    });

    return { start, stop };
  }
</script>

</body>
</html>
